import{stringify as Y}from"query-string";import{stringify as g}from"query-string";var _=r=>{switch(r){case"ne":case"gte":case"lte":return`_${r}`;case"contains":return"_like";case"eq":default:return""}};var h=r=>{if(r&&r.length>0){let s=[],e=[];return r.map(t=>{s.push(t.field),e.push(t.order)}),{_sort:s,_order:e}}};var f=r=>{let s={};return r&&r.map(e=>{if(e.operator==="or"||e.operator==="and")throw new Error(`[@refinedev/simple-rest]: \`operator: ${e.operator}\` is not supported. You can create custom data provider. https://refine.dev/docs/api-reference/core/providers/data-provider/#creating-a-data-provider`);if("field"in e){let{field:t,operator:o,value:n}=e;if(t==="q"){s[t]=n;return}let d=_(o);s[`${t}${d}`]=n}}),s};import T from"axios";var y=T.create();y.interceptors.response.use(r=>r,r=>{var e,t,o;let s={...r,message:(t=(e=r.response)==null?void 0:e.data)==null?void 0:t.message,statusCode:(o=r.response)==null?void 0:o.status};return Promise.reject(s)});var w=(r,s=y)=>({getList:async({resource:e,pagination:t,filters:o,sorters:n,meta:d})=>{let i=`${r}/${e}`,{current:c=1,pageSize:a=10,mode:p="server"}=t??{},{headers:$,method:m}=d??{},x=m??"get",M=f(o),u={};p==="server"&&(u._start=(c-1)*a,u._end=c*a);let l=h(n);if(l){let{_sort:F,_order:S}=l;u._sort=F.join(","),u._order=S.join(",")}let{data:v,headers:q}=await s[x](`${i}?${g(u)}&${g(M)}`,{headers:$}),O=+q["x-total-count"];return{data:v,total:O||v.length}},getMany:async({resource:e,ids:t,meta:o})=>{let{headers:n,method:d}=o??{},i=d??"get",{data:c}=await s[i](`${r}/${e}?${g({id:t})}`,{headers:n});return{data:c}},create:async({resource:e,variables:t,meta:o})=>{let n=`${r}/${e}`,{headers:d,method:i}=o??{},c=i??"post",{data:a}=await s[c](n,t,{headers:d});return{data:a}},update:async({resource:e,id:t,variables:o,meta:n})=>{let d=`${r}/${e}/${t}`,{headers:i,method:c}=n??{},a=c??"patch",{data:p}=await s[a](d,o,{headers:i});return{data:p}},getOne:async({resource:e,id:t,meta:o})=>{let n=`${r}/${e}/${t}`,{headers:d,method:i}=o??{},c=i??"get",{data:a}=await s[c](n,{headers:d});return{data:a}},deleteOne:async({resource:e,id:t,variables:o,meta:n})=>{let d=`${r}/${e}/${t}`,{headers:i,method:c}=n??{},a=c??"delete",{data:p}=await s[a](d,{data:o,headers:i});return{data:p}},getApiUrl:()=>r,custom:async({url:e,method:t,filters:o,sorters:n,payload:d,query:i,headers:c})=>{let a=`${e}?`;if(n){let m=h(n);if(m){let{_sort:x,_order:M}=m,u={_sort:x.join(","),_order:M.join(",")};a=`${a}&${g(u)}`}}if(o){let m=f(o);a=`${a}&${g(m)}`}i&&(a=`${a}&${g(i)}`);let p;switch(t){case"put":case"post":case"patch":p=await s[t](e,d,{headers:c});break;case"delete":p=await s.delete(e,{data:d,headers:c});break;default:p=await s.get(a,{headers:c});break}let{data:$}=p;return Promise.resolve({data:$})}});var J=w;export{y as axiosInstance,J as default,f as generateFilter,h as generateSort,_ as mapOperator,Y as stringify};
//# sourceMappingURL=index.js.map